.container
	.row
		.col-12.bg-light.p-3
			
			#app02-15

				h2 Counter {{ counter }}
				h3 Result: {{ condition }}
				button.btn.btn-primary(@click="add") Add
				button.btn.btn-primary(@click="sub") Sub
				p Строка в коде повторяется, надо оптимизировать
				p Вызывается result(), хотя не должен. Он неиспользуется. Почему? Потому что vue пересчитывает все переменные

				hr

				h2 Counter 2: {{ counter2 }}
				h3 Result: {{ result() }}
				button.btn.btn-primary(@click="add2") Add
				button.btn.btn-primary(@click="sub2") Sub
				p Теперь не повторяется. Оптимизировано через метод. Использование метода, будет запускать функцию всегда, при каждом обращении к нему
				p Также будет выполняться computedResult. Вычисляемое свойство пересчитывается всякий раз, когда изменится одна из его реактивных зависимостей

				hr

				h2 Counter 3: {{ counter3 }}
				h3 Computed result: {{ computedResult }}
				button.btn.btn-primary(@click="counter3++") Add 
				button.btn.btn-primary(@click="counter3--") Sub
				p Вычисленное значение. Значение computedResult выполниться лишь когда измениться переменная counter2. Не будет пересчитываться каждый раз
				p По нажатию на кнопки вызовется только result()
				p computedResult не вызывается потому что не зависит от counter3
				br
				b Зачем нужно кеширование? Представьте, есть «дорогое» вычисляемое свойство A, требующее цикла по огромному массиву и выполняющее множество вычислений. И пусть ещё будут другие вычисляемые свойства, в свою очередь, зависящие от A. Без кэширования геттер A будет запускаться куда чаще необходимого! В тех же случаях, когда кэширования нужно избежать — используйте методы

				
			